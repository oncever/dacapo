package org.dacapo.derby;

import java.sql.Connection;
import java.sql.SQLException;

import org.apache.derbyTesting.system.oe.client.Display;
import org.apache.derbyTesting.system.oe.direct.Standard;

public final class Operation extends Standard
{

  private int retryLimit;

  /**
   * Construct a wrapper subclasss of the
   * org.apache.derbyTesting.system.oe.direct.Standard operations class. The
   * wrapper catches exceptions generated by the operations, such as timeouts
   * and deadlocks and will retry with the same data up to
   * <code>retryLimit</code> times.
   * 
   * @param conn
   *          A connection to the derby database.
   * @param retryLimit
   *          The maximum number of retries before catastrophic failure.
   * @throws SQLException
   */
  public Operation(Connection conn, int retryLimit) throws SQLException
  {
    super(conn);
    this.retryLimit = retryLimit;
  }

  public void stockLevel(Display display, Object displayData, short w, short d,
      int threshold) throws Exception
  {
    boolean done = false;
    int retry = 0;
    Exception lastE = null;
    while (retry < retryLimit && !done)
    {
      try
      {
        super.stockLevel(display, displayData, w, d, threshold);
        done = true;
      } catch (Exception e)
      {
        retry++;
        lastE = e;
        conn.rollback();
      }
    }
    check(done, lastE);
  }

  public void orderStatus(Display display, Object displayData, short w,
      short d, String customerLast) throws Exception
  {
    boolean done = false;
    int retry = 0;
    Exception lastE = null;
    while (retry < retryLimit && !done)
    {
      try
      {
        super.orderStatus(display, displayData, w, d, customerLast);
        done = true;
      } catch (Exception e)
      {
        retry++;
        lastE = e;
        conn.rollback();
      }
    }
    check(done, lastE);
  }

  public void orderStatus(Display display, Object displayData, short w,
      short d, int c) throws Exception
  {
    boolean done = false;
    int retry = 0;
    Exception lastE = null;
    while (retry < retryLimit && !done)
    {
      try
      {
        super.orderStatus(display, displayData, w, d, c);
        done = true;
      } catch (Exception e)
      {
        retry++;
        lastE = e;
        conn.rollback();
      }
    }
    check(done, lastE);
  }

  public void payment(Display display, Object displayData, short w, short d,
      short cw, short cd, String customerLast, String amount) throws Exception
  {
    boolean done = false;
    int retry = 0;
    Exception lastE = null;
    while (retry < retryLimit && !done)
    {
      try
      {
        super.payment(display, displayData, w, d, cw, cd, customerLast, amount);
        done = true;
      } catch (Exception e)
      {
        retry++;
        lastE = e;
        conn.rollback();
      }
    }
    check(done, lastE);
  }

  public void payment(Display display, Object displayData, short w, short d,
      short cw, short cd, int c, final String amount) throws Exception
  {
    boolean done = false;
    int retry = 0;
    Exception lastE = null;
    while (retry < retryLimit && !done)
    {
      try
      {
        super.payment(display, displayData, w, d, cw, cd, c, amount);
        done = true;
      } catch (Exception e)
      {
        retry++;
        lastE = e;
        conn.rollback();
      }
    }
    check(done, lastE);
  }

  public void newOrder(Display display, Object displayData, short w, short d,
      int c, int[] items, short[] quantities, short[] supplyW) throws Exception
  {
    boolean done = false;
    int retry = 0;
    Exception lastE = null;
    while (retry < retryLimit && !done)
    {
      try
      {
        super.newOrder(display, displayData, w, d, c, items, quantities,
            supplyW);
        done = true;
      } catch (Exception e)
      {
        retry++;
        lastE = e;
        conn.rollback();
      }
    }
    check(done, lastE);
  }

  public void scheduleDelivery(Display display, Object displayData, short w,
      short carrier) throws Exception
  {
    boolean done = false;
    int retry = 0;
    Exception lastE = null;
    while (retry < retryLimit && !done)
    {
      try
      {
        super.scheduleDelivery(display, displayData, w, carrier);
        done = true;
      } catch (Exception e)
      {
        retry++;
        lastE = e;
        conn.rollback();
      }
    }
    check(done, lastE);
  }

  private static void check(boolean done, Exception lastE) throws Exception
  {
    if (!done && lastE != null)
    {
      lastE.printStackTrace();
      throw lastE;
    }
  }
}
